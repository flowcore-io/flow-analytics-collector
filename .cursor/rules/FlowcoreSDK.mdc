---
description: if I ask you to look at the flowcore sdk
globs: 
alwaysApply: false
---
TITLE: Setting Up Real-time Notifications with Flowcore SDK (TypeScript)
DESCRIPTION: This snippet demonstrates how to set up real-time notifications for event ingestion using the "NotificationClient". It involves creating an RxJS "Subject" to handle incoming "NotificationEvent"s, subscribing to it, and then initializing the "NotificationClient" with the subject, an OIDC client for authentication, and optional subscription filters (tenant, data core, flow type, event type) and configuration options (reconnect interval, max reconnects, max events, custom logger). The client connects via WebSocket and can be explicitly disconnected. This operation requires OIDC authentication.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore SDK/index.mdx#_snippet_31

LANGUAGE: TypeScript
CODE:
```
import { NotificationClient, type NotificationEvent } from "@flowcore/sdk"
import { Subject } from "rxjs"

// Create an RxJS Subject to handle the notifications
const subject = new Subject<NotificationEvent>()

// Subscribe to handle notifications
subject.subscribe({
  next: (event) => {
    console.log("Received event:", event)
    // event.data contains:
    // {
    //   tenant: string;      // Tenant ID
    //   eventId: string;     // Unique event ID
    //   dataCoreId: string;  // Data Core ID
    //   flowType: string;    // Flow Type name
    //   eventType: string;   // Event Type name;
    //   validTime: string;   // Timestamp
    // }
  },
  error: (error) => console.error("Error:", error),
  complete: () => console.log("Notification stream completed")
})

// Create the notification client
const client = new NotificationClient(
  subject,
  oidcClient, // Your OIDC client for authentication
  {
    tenant: "your-tenant-name",
    dataCore: "your-data-core-name",
    flowType: "your-flow-type-name",     // Optional: Subscribe to specific Flow Type
    eventType: "your-event-type-name"    // Optional: Subscribe to specific Event Type
  },
  {
    reconnectInterval: 1000,             // Optional: Milliseconds between reconnection attempts
    maxReconnects: 5,                    // Optional: Maximum number of reconnection attempts
    maxEvents: 1000,                     // Optional: Maximum number of events to receive
    logger: customLogger                 // Optional: Custom logger implementation
  }
)

// Connect to start receiving notifications
await client.connect()

// Disconnect when done
client.disconnect()
```

----------------------------------------

TITLE: Installing Flowcore SDK with npm
DESCRIPTION: Installs the Flowcore SDK using the npm package manager. This command adds the SDK as a dependency to your project via JSR.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore SDK/index.mdx#_snippet_2

LANGUAGE: bash
CODE:
```
npx jsr add @flowcore/sdk
```

----------------------------------------

TITLE: Defining Core API Exception Classes in TypeScript
DESCRIPTION: This comprehensive TypeScript code defines a base ApiException class and several standard HTTP-status-code-specific exception classes. It serves as the foundation for consistent error handling in an API, allowing developers to throw specific exceptions that map to HTTP status codes and custom error codes. The ApiException class extends the built-in Error class, adding status and code properties. Derived classes like ApiConflictException (409), ApiForbiddenException (403), ApiInternalServerErrorException (500), ApiNotFoundException (404), ApiUnauthorizedException (401), and ApiUnprocessableContentException (422) provide specialized error handling with predefined status and error codes. ApiUnprocessableContentException also includes optional 'on' and 'errors' properties for detailed validation feedback.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/api-exceptions.mdx#_snippet_1

LANGUAGE: typescript
CODE:
```
/**
 * Base class for all API exceptions. This class extends the built-in Error class and adds properties for HTTP status code and error code.
 * 
 * @property {number} status - The HTTP status code for the exception.
 * @property {string} code - The error code for the exception.
 * @example
 * ```ts
 * // example exception implementation
 * export class ApiNotFoundException extends ApiException {
        public status = 404
        public code = "NOT_FOUND"
    * }
 * ```
 * ```ts
 * // example usage
 * throw new ApiNotFoundException("User not found", "user", { id: "123" })
 * ```
*/
export abstract class ApiException extends Error {
    public status = 0
    public code = ""
}

// ==============================
// Exceptions
// ==============================

/**
 * Represents an API conflict exception. This exception is thrown when a request conflicts with the current state of the resource.
 *
 * @property {number} status - The HTTP status code for the exception, which is 409.
 * @property {string} code - The error code for the exception, which is "CONFLICT".
 */
export class ApiConflictException extends ApiException {
    public status = 409
    public code = "CONFLICT"
}

/**
 * Represents an API forbidden exception. This exception is thrown when the server refuses to authorize the request.
 *
 * @property {number} status - The HTTP status code for the exception, which is 403.
 * @property {string} code - The error code for the exception, which is "FORBIDDEN".
 */
export class ApiForbiddenException extends ApiException {
    public status = 403
    public code = "FORBIDDEN"
}

/**
 * Represents an API internal server error exception. This exception is thrown when the server encounters an unexpected condition that prevents it from fulfilling the request.
 *
 * @property {number} status - The HTTP status code for the exception, which is 500.
 * @property {string} code - The error code for the exception, which is "INTERNAL_SERVER_ERROR".
 */
export class ApiInternalServerErrorException extends ApiException {
    public status = 500
    public code = "INTERNAL_SERVER_ERROR"
}

/**
 * Represents an API not found exception. This exception is thrown when the requested resource could not be found.
 *
 * @property {number} status - The HTTP status code for the exception, which is 404.
 * @property {string} code - The error code for the exception, which is "NOT_FOUND".
 */
export class ApiNotFoundException extends ApiException {
    public status = 404
    public code = "NOT_FOUND"
}

/**
 * Represents an API unauthorized exception. This exception is thrown when the request lacks valid authentication credentials for the target resource.
 *
 * @property {number} status - The HTTP status code for the exception, which is 401.
 * @property {string} code - The error code for the exception, which is "UNAUTHORIZED".
 *
 * @param {string} message - The error message for the exception.
 */
export class ApiUnauthorizedException extends ApiException {
    public status = 401
    public code = "UNAUTHORIZED"

    constructor() {
        super("Unauthorized")
    }
}

/**
 * Represents an API unprocessable content exception. This exception is thrown when the server understands the content type of the request entity, and the syntax of the request entity is correct, but it was unable to process the contained instructions.
 *
 * @property {number} status - The HTTP status code for the exception, which is 422.
 * @property {string} code - The error code for the exception, which is "UNPROCESSABLE_CONTENT".
 * @property {(string | undefined)} on - The field or property that caused the error.
 * @property {(Record<string, string> | undefined)} errors - A record of errors, where each key is the field or property name and the value is the error message.
 *
 * @param {string} message - The error message for the exception.
 * @param {(string | undefined)} on - The field or property that caused the error.
 * @param {(Record<string, string> | undefined)} errors - A record of errors.
 */
export class ApiUnprocessableContentException extends ApiException {
    public status = 422
    public code = "UNPROCESSABLE_CONTENT"
    public on?: string
    public errors?: Record<string, string>

    constructor(message: string, on?: string, errors?: Record<string, string>) {
        super(message)
        this.on = on
        this.errors = errors
    }
}
```

----------------------------------------

TITLE: Ingesting Data with cURL (Shell)
DESCRIPTION: This `curl` command demonstrates how to send a POST request with JSON data to your Flowcore ingestion URL from a Unix-compatible terminal (e.g., macOS). It sets the `Content-Type` header to `application/json` and includes a simple JSON payload. Replace `<your-ingestion-url>` and `<your-name>` with your specific details.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Flowcathon/1-ingestion.mdx#_snippet_5

LANGUAGE: Shell
CODE:
```
curl -X POST "<your-ingestion-url>" \
-H "Content-Type: application/json" \
-d '{"hello": "<your-name>"}'
```

----------------------------------------

TITLE: Configuring PII for Event Types in Data Core
DESCRIPTION: This YAML snippet demonstrates how to configure Personally Identifiable Information (PII) handling for an event type within a Data Core manifest. It includes enabling PII, specifying the `piiKey` (JSON path for entity ID), and defining a `piiSchema` for masking sensitive fields using faker methods, patterns, or redaction rules.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore CLI/create-resources-cli.mdx#_snippet_3

LANGUAGE: yaml
CODE:
```
tenant: example-tenant
dataCore:
  name: example-data-core
  description: "An example Data Core"
  flowTypes:
    users:
      description: "User data flow type"
      eventTypes:
        user.created.0:
          description: "User created event"
          piiEnabled: true
          piiKey: ".userId"
          piiSchema: |
            {
              "firstName": {
                "faker": "person.firstName"
              },
              "lastName": {
                "faker": "person.lastName"
              },
              "email": {
                "faker": "internet.email"
              },
              "address": {
                "faker": "location.streetAddress"
              },
              "phoneNumber": {
                "type": "string",
                "pattern": "[0-9]{3}-[0-9]{3}-[0-9]{4}"
              },
              "ssn": {
                "type": "string",
                "redact": {
                  "char": "*",
                  "length": 9
                }
              }
            }
```

----------------------------------------

TITLE: Initializing IAM Validation and Defining Access Service (TypeScript)
DESCRIPTION: This snippet demonstrates the setup of the `IamValidateBuilder` for IAM validation, configuring it with Redis, a hash function, and a logger. It also defines the `RequestedAccessService` class, which allows chaining methods to build a list of requested resource accesses (e.g., `onDataCore`) and then evaluate them against the authenticated user's permissions.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/iam-validation.mdx#_snippet_4

LANGUAGE: typescript
CODE:
```
// services/request-access.ts
import env from "@/env"
import type { RequestedAccess } from "@components/iam-validation"
import { type FrnAction, FrnType, IamValidateBuilder, buildListFrn } from "@components/iam-validation"
import type { FlowcoreAuthenticatedUser } from "@components/jwks-guard"
import * as xxHash from "@jabr/xxhash64"
import { Redis } from "ioredis"

// Utilise your logger of choice here, utilising the flowcore logger library
const logger = createLogger("iam-validation")

const hash = await xxHash.create3()
const iamValidation = new IamValidateBuilder(env.IAM_API_URL)
  .withRedisClient(new Redis(env.IAM_REDIS_URL))
  .withHash(hash)
  .withType("users")
  .withLogger(logger)
  .withMode("organization")

export class RequestedAccessService {
  private requestedAccess: RequestedAccess = []

  constructor(private readonly flowcoreUser: FlowcoreAuthenticatedUser) {}

  /**
   * Adds a Data Core access request to the list of requested accesses.
   * @param {FrnAction | FrnAction[]} action - The action(s) to be performed on the Data Core.
   * @param {string} organizationId - The ID of the organization.
   * @param {string} [id] - The ID of the specific Data Core. If not provided, defaults to "*" (all Data Cores).
   * @returns {this} The current instance for method chaining.
   */
  onDataCore(action: FrnAction | FrnAction[], organizationId: string, id?: string): this {
    this.requestedAccess.push({
      action,
      resource: buildListFrn([{ type: FrnType.DATA_CORE, id: id ?? "*" }], organizationId),
    })

    return this
  }

  // add `on<resource>` methods for other resources

  /**
   * Evaluates the requested accesses against the user's permissions.
   * @returns {Promise<void>} A promise that resolves to true if the user has all requested permissions, false otherwise.
   */
  evaluate(): Promise<void> {
    return iamValidation.build(this.requestedAccess)({ flowcoreUser: this.flowcoreUser })
  }
}
```

----------------------------------------

TITLE: Initializing FlowcoreClient in TypeScript
DESCRIPTION: Demonstrates various ways to initialize the FlowcoreClient, including authentication with a bearer token or an API key, and configuring retry behavior. The client is the primary interface for interacting with the Flowcore API.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore SDK/index.mdx#_snippet_3

LANGUAGE: typescript
CODE:
```
import { FlowcoreClient } from "@flowcore/sdk"

// 1. With a bearer token
const clientWithBearer = new FlowcoreClient({
  getBearerToken: async (): Promise<string> => {
    const token = await someMethodToGetToken()
    return token
  },
})

// 2. With an API key
const clientWithApiKey = new FlowcoreClient({
  apiKeyId: "my-api-key-id",
  apiKey: "my-api-key",
})

// 3. With retry configuration
const clientWithRetry = new FlowcoreClient({
  apiKeyId: "my-api-key-id",
  apiKey: "my-api-key",
  retry: {
    delay: 100,    // Delay in milliseconds between retries
    maxRetries: 5, // Maximum number of retry attempts
  },
})
```

----------------------------------------

TITLE: Installing Flowcore CLI via npm (Bash)
DESCRIPTION: This command installs the Flowcore Command Line Interface (CLI) globally using npm. The CLI allows interaction with Flowcore from the terminal. Node.js is a prerequisite for this installation.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/index.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
npm install -g @flowcore/cli
```

----------------------------------------

TITLE: Installing Flowcore SDK with Bun
DESCRIPTION: Installs the Flowcore SDK using the Bun package manager. This command adds the SDK as a dependency to your project via JSR.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore SDK/index.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
bunx jsr add @flowcore/sdk
```

----------------------------------------

TITLE: Scaffolding Flowcore Data Core and Scenario (YAML)
DESCRIPTION: This YAML configuration file defines a Flowcore Data Core named 'flowcathon' and a scenario with associated transformers and event types. It specifies the tenant name, data core properties like description, public status, and delete protection, along with flow types and event types for different ingestion challenges. The scenario section links to the Data Core, defines transformer parameters (including a proxy endpoint and a secret), and references an artifact URL for the transformer blueprint.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Flowcathon/1-ingestion.mdx#_snippet_0

LANGUAGE: YAML
CODE:
```
version: 1
## ⬇️ INSERT YOUR TENANT NAME HERE ⬇️
tenant: <your-tenant-name>  # The name of your tenant, this can be found by visiting your tenant page on flowcore.io
dataCore:
  name: flowcathon
  deleteProtection: false
  isPublic: false
  description: Data related to the Flowcathon challenges
  flowTypes: 
    ingestion.0:
      description: Contains the data for the ingestion challenge
      eventTypes:
        ingestion.challenge-a-ingested.0:
          description: Collecting ingestions for the ingestion challenge A
        ingestion.challenge-b-ingested.0:
          description: Collecting ingestions for the ingestion challenge B
        ingestion.challenge-c-ingested.0:
          description: Collecting ingestions for the ingestion challenge C
scenario:
  name: flowcathon
  description: >-
    This scenario is used for development of the Application Flowcathon
    application
  transformers:
    ingestion:
      description: Ingestion Challenge
      dataCore: flowcathon
      flowType: ingestion.0
      events:
        - ingestion.challenge-a-ingested.0
        - ingestion.challenge-b-ingested.0
        - ingestion.challenge-c-ingested.0
      parameters:
        - name: PROXY_ENDPOINT
          type: manual
          value: >-
            https://flowcathon.customer.flowcore.io/api/transform/ingestion.0
        - name: PROXY_HEADER_SECRET
          type: secret
          value: transformer-secret-flowcathon
      blueprint:
        artifactUrl: >-
          https://flowcore-public-runtimes.s3.eu-west-1.amazonaws.com/transformer-proxy-1.4.1.zip
```

----------------------------------------

TITLE: Securing Elysia Endpoint with Flowcore User Guard - TypeScript
DESCRIPTION: This code shows how to apply the `authenticatedFlowcoreUser` plugin to a specific Elysia endpoint, in this case, `/v1/data-cores`. It also includes a `beforeHandle` hook that utilizes the `requestAccessService` to perform fine-grained access control based on the authenticated user's context and route parameters, ensuring authorized access to data cores.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/jwks-guard.mdx#_snippet_4

LANGUAGE: typescript
CODE:
```
// server/routes/api/v1/data-cores/index.ts
export default new Elysia({
  prefix: "/v1/data-cores",
  tags: ["data-cores"],
  detail: {
    security: [{ bearerAuth: [], oauth2: [] }],
  },
})
  .use(authenticatedFlowcoreUser)
  .get("/", async () => {
    return {
      message: "Hello, world!",
    }
  }, {
    beforeHandle: ({ flowcoreUser, RequestedAccessService, params}) => 
      requestAccessService.onDataCore(FrnAction.Write, params.organizationId, params.dataCoreId ?? "*"),
    params: t.Object({
      organizationId: t.String(),
      dataCoreId: t.Optional(t.String()),
    }),
  })
```

----------------------------------------

TITLE: Defining Expected Output for Transformer Unit Tests in JSON
DESCRIPTION: This JSON array defines the expected input and output for unit tests of the data transformation code. Each object in the array represents a test case, specifying an 'input' payload (e.g., temperature, wind speed) and the corresponding 'output' payload, which includes the original fields plus the 'distance_from_optimal_heating' calculated by the transformer.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/example.mdx#_snippet_1

LANGUAGE: json
CODE:
```
[
  {
    "input": {
      "temp_c": "-19",
      "wind_speed_mps": "10",
      "wind_dir": "west"
    },
    "output": {
      "eventid": ":uuid:",
      "validtime": ":date:",
      "temp_c": "-19",
      "wind_speed_mps": "10",
      "wind_dir": "west",
      "distance_from_optimal_heating": 41
    }
  },
  {
    "input": {
      "temp_c": "2",
      "wind_speed_mps": "10",
      "wind_dir": "east"
    },
    "output": {
      "eventid": ":uuid:",
      "validtime": ":date:",
      "temp_c": "2",
      "wind_speed_mps": "10",
      "wind_dir": "east",
      "distance_from_optimal_heating": 20
    }
  }
]
```

----------------------------------------

TITLE: Core IAM Validation Library Definition (TypeScript)
DESCRIPTION: This TypeScript code defines the core components of the IAM Validation library. It includes the `IamForbiddenException` for handling authorization errors, the `requestedAccess` schema for defining validation requests, the `IamValidationResponse` type, the `IamValidateBuilder` class for constructing and executing validation logic, and utility enums (`FrnType`, `FrnAction`) and functions (`buildFrn`, `buildListFrn`) for managing Flowcore Resource Names (FRNs).
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/iam-validation.mdx#_snippet_3

LANGUAGE: typescript
CODE:
```
// lib/iam-validation.ts
import { ApiException } from "@components/api-exceptions"
import type { Logger } from "@components/logger"
import type * as xxHash from "@jabr/xxhash64"
import { type Static, Type } from "@sinclair/typebox"
import { BunSqliteKeyValue } from "bun-sqlite-key-value"

/**
 * Represents an API forbidden exception. This exception is thrown when the server refuses to authorize the request.
 *
 * @property {number} status - The HTTP status code for the exception, which is 403.
 * @property {string} code - The error code for the exception, which is "FORBIDDEN".
 */
export class IamForbiddenException extends ApiException {
  public status = 403
  public code = "FORBIDDEN"

  constructor(
    message: string,
    public readonly validPolicies?: { policyFrn: string; statementId: string }[],
    public readonly invalidRequest?: RequestedAccess,
  ) {
    super(message)
  }
}

/**
 * Defines the structure of requested access for IAM validation.
 *
 * @property {action} - The action or actions to validate against.
 * @property {resource} - The resource to validate, in order of granularity. First match wins.
 */
export const requestedAccess = Type.Array(
  Type.Object({
    action: Type.Union([Type.String(), Type.Array(Type.String())], {
      description: "The action or actions to validate against",
      examples: ["read", "write", "fetch", "ingest"],
    }),
    resource: Type.Array(Type.String({ pattern: "^frn::" }), {
      description: "The resource to validate, in order of granularity. First match wins.",
      examples: [
        [
          "frn::tenant",
          "frn::tenant:data-core/24005dde-7476-4692-aec4-175d2e5a9b9e",
          "frn::tenant:flow-type/6a394228-e1a1-4491-b280-0117f481be32",
          "frn::tenant:event-type/ffff7fe3-45c7-4a96-afe2-2519ee342d69"
        ],
        [
          "frn::13ea0ce0-2f5c-46c4-b4f2-e0e15c5d1cda",
          "frn::13ea0ce0-2f5c-46c4-b4f2-e0e15c5d1cda:data-core/24005dde-7476-46c4-b4f2-e0e15c5d1cda",
          "frn::13ea0ce0-2f5c-46c4-b4f2-e0e15c5d1cda:flow-type/6a394228-e1a1-4491-b280-0117f481be32",
          "frn::13ea0ce0-2f5c-46c4-b4f2-e0e15c5d1cda:event-type/ffff7fe3-45c7-4a96-afe2-2519ee342d69"
        ]
      ]
    })
  })
)

/**
 * Represents the type of requested access for IAM validation.
 */
export type RequestedAccess = Static<typeof requestedAccess>

/**
 * Represents the response from IAM validation.
 *
 * @property {valid} - Indicates if the validation was successful.
 * @property {validPolicies} - The policies that were validated.
 * @property {checksum} - The checksum of the validation request.
 * @property {invalidRequest} - The invalid request details if validation failed.
 */
export type IamValidationResponse =
  | {
      valid: true
      validPolicies: { policyFrn: string; statementId: string }[]
      checksum: string
    }
  | {
      valid: false
      invalidRequest: RequestedAccess
      validPolicies: { policyFrn: string; statementId: string }[]
    }

const HASH_KEY_TTL_IN_MS = 300_000

export class IamValidateBuilder {
  private hash!: xxHash.Hasher
  private type: "users" | "keys" = "users"
  private mode: "tenant" | "organization" = "tenant"
  private logger: Logger | undefined
  private localCache: BunSqliteKeyValue = new BunSqliteKeyValue(":memory:", {
    ttlMs: 300_000,
  })

  constructor(private readonly iamApiUrl: string) {}

  /**
   * Sets the hash function for generating checksums.
   *
   * @param {xxHash.Hasher} hash - The hash function instance.
   * @returns {IamValidateBuilder} - This instance for method chaining.
   */
  public withHash(hash: xxHash.Hasher): IamValidateBuilder {
    this.hash = hash
    return this
  }

  /**
   * Sets the type of validation to perform.
   *
   * @param {"users" | "keys"} type - The type of validation.
   * @returns {IamValidateBuilder} - This instance for method chaining.
   */
  public withType(type: "users" | "keys"): IamValidateBuilder {
    this.type = type
    return this
  }

  /**
   * Sets the mode of validation to perform.
   *
   * @param {"tenant" | "organization"} mode - The mode of validation.
   * @returns {IamValidateBuilder} - This instance for method chaining.
   */
  public withMode(mode: "tenant" | "organization"): IamValidateBuilder {
    this.mode = mode
    return this
  }

  /**
   * Sets the logger for logging validation events.
   *
   * @param {Logger} logger - The logger instance.
   * @returns {IamValidateBuilder} - This instance for method chaining.
   */
  public withLogger(logger: Logger): IamValidateBuilder {
    this.logger = logger
    return this
  }

  /**
   * Builds the IAM validation process.
   *
   * @param {RequestedAccess} requestedAccess - The requested access details.
   * @returns {(flowcoreUser: FlowcoreAuthenticatedUser) => Promise<void>} - A promise that resolves to void.
   */
  public build(
    requestedAccess: RequestedAccess,
  ): (options: { flowcoreUser: FlowcoreAuthenticatedUser }) => Promise<void> {
    const checksum = this.hash.hash(JSON.stringify(requestedAccess), "hex").toString()
    return async ({ flowcoreUser }: { flowcoreUser: FlowcoreAuthenticatedUser }): Promise<void> => {
      const { id } = flowcoreUser
      const localChecksum = this.localCache.get<boolean>(`${id}-${checksum}`)
      if (localChecksum === true) {
        return
      }

      const validation = await fetch(`${this.iamApiUrl}/api/v1/validate/${this.type}/${id}`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          mode: this.mode,
          requestedAccess
        })
      })

      const data = (await validation.json()) as IamValidationResponse

      if (data.valid) {
        this.localCache.set(`${id}-${data.checksum}`, true, HASH_KEY_TTL_IN_MS)
        this.logger?.debug(`IAM validation passed for ${this.type} ${id} with checksum ${data.checksum}`)
      } else {
        this.logger?.error("IAM validation failed", data)
        throw new IamForbiddenException("IAM validation failed", data.validPolicies, data.invalidRequest)
      }
    }
  }
}

/**
 * Enum for defining the types of FRNs.
 *
 * @enum {string}
 */
export enum FrnType {
  USER = "user",
  KEY = "key",
  ROLE = "role",
  POLICY = "policy",
  ORGANIZATION = "organization",
  DATA_CORE = "data-core",
  FLOW_TYPE = "flow-type",
  EVENT_TYPE = "event-type",
  ALL = "*"
}

/**
 * Enum for defining the actions that can be performed on FRNs.
 *
 * @enum {string}
 */
export enum FrnAction {
  READ = "read",
  WRITE = "write",
  INGEST = "ingest",
  FETCH = "fetch",
  ALL = "*"
}

/**
 * Builds a fully qualified FRN string.
 *
 * @param {string} tenantOrOrganizationId - The tenant or organization ID.
 * @param {FrnType} type - The type of FRN.
 * @param {string} [id] - The ID of the FRN.
 * @returns {string} - The fully qualified FRN string.
 */
export const buildFrn = (tenantOrOrganizationId: string, type: FrnType, id?: string): string => {
  return `frn::${tenantOrOrganizationId}:${type}${id ? `/${id}` : ""}`
}

/**
 * Builds a list of fully qualified FRN strings.
 *
 * @param {{ type: FrnType; id?: string }[]} items - The list of items to build FRNs for.
 * @param {string} tenantOrOrganizationId - The tenant or organization ID.
 * @returns {string[]} - A list of fully qualified FRN strings.
 */
export const buildListFrn = (items: { type: FrnType; id?: string }[], tenantOrOrganizationId: string): string[] => {
  return [
    buildFrn(tenantOrOrganizationId, FrnType.ALL),
    ...items.map((item) => buildFrn(tenantOrOrganizationId, item.type, item.id))
  ]
}
```

----------------------------------------

TITLE: Creating Flowcore Tenant API Key with CLI (Bash)
DESCRIPTION: Explains how to generate a new API key for a Flowcore Tenant using the `flowcore auth new key` command. The API key is essential for authenticating with the Flowcore Platform and is tied to a specific tenant.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Installation/index.mdx#_snippet_6

LANGUAGE: bash
CODE:
```
flowcore auth new key -t <tenant> dedicated-cluster
```

----------------------------------------

TITLE: Sending Single Event Data via Webhook - JSON
DESCRIPTION: This JSON snippet represents the basic structure for sending a single event's data to Flowcore via a webhook. The content within the object should be the actual event payload that will be ingested into the selected Data Core, Flow Type, and Event Type.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Ingestion/ingestion-options.mdx#_snippet_0

LANGUAGE: json
CODE:
```
{
  // event data
}
```

----------------------------------------

TITLE: Integrating Redis Predicate with Flowcore Webhook and Transformer (TypeScript)
DESCRIPTION: This `flowcore.ts` example shows how to integrate the Redis predicate with Flowcore's `WebhookBuilder` and `transformerFactory`. It configures a webhook client to use the Redis predicate for checking event success and a transformer client to notify Redis upon successful processing, ensuring end-to-end event tracking.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/Predicates/redis-predicate.mdx#_snippet_5

LANGUAGE: typescript
CODE:
```
// flowcore.ts

import env from "@/env"
import { redisPredicateFactory } from "@/lib/redis-predicate-factory"
import { transformerFactory } from "@/lib/transformer-factory"
import { WebhookBuilder } from "@flowcore/sdk-transformer-core"

// Setup the predicate check, utilising Redis
const predicateCheck = redisPredicateFactory({
  redisUrl: env.REDIS_URL,
  redisEventIdKey: env.REDIS_KEY_PATTERN
})

// Setup the webhook client, utilising the predicate check
export const webhookClient = new WebhookBuilder({
  baseUrl: env.FLOWCORE_WEBHOOK_BASE_URL,
  tenant: env.FLOWCORE_TENANT,
  dataCore: env.FLOWCORE_DATA_CORE,
  apiKey: env.FLOWCORE_API_KEY
})
  .withPredicate({
    predicate: predicateCheck.check
  })
  .withRetry()
  .factory()

// Setup the transformer client, utilising the predicate check
export const transformerClient = transformerFactory({
  onSuccess: predicateCheck.notify,
  secret: env.TRANSFORMER_SECRET
})
```

----------------------------------------

TITLE: Complete Data Core Configuration with Stream Flow Type (YAML)
DESCRIPTION: This comprehensive YAML snippet shows the full `dataCore` section of the `flowcore.yaml` file, demonstrating how the newly added `stream.0` Flow Type integrates with existing configurations. It illustrates the structure for defining multiple Flow Types and their associated Event Types within a Flowcore Data Core manifest.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Flowcathon/2-data-core.mdx#_snippet_1

LANGUAGE: yaml
CODE:
```
# flowcore.yaml
dataCore:
  name: flowcathon
  deleteProtection: true
  isPublic: false
  description: This Data Core contains the data for the Application Flowcathon application
  flowTypes:
    ingestion.0:
      description: Contains the data for the ingesdtion challenge
      eventTypes:
        ingestion.challenge-a-ingested.0:
          description: Collecting ingestions for the ingestion challenge A
        ingestion.challenge-b-ingested.0:
          description: Collecting ingestions for the ingestion challenge B
        ingestion.challenge-c-ingested.0:
          description: Collecting ingestions for the ingestion challenge C
    # V- Add this Flow Type -V
    stream.0:
      description: Contains the data for the stream challenge
      eventTypes:
        stream.challenge-b-solved.0:
          description: Collecting stream data for the stream challenge B
```

----------------------------------------

TITLE: Integrating IAM Access Evaluation into Elysia Endpoint (TypeScript)
DESCRIPTION: This example shows how to integrate the `RequestedAccessService` into an Elysia endpoint's `beforeHandler`. It demonstrates creating an instance of `RequestedAccessService`, specifying required access (e.g., `FrnAction.READ` on a Data Core for a specific tenant), and then evaluating these permissions before the main handler executes, ensuring authorized access.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/iam-validation.mdx#_snippet_5

LANGUAGE: typescript
CODE:
```
// my-endpoint.ts

export const myEndpoint = new Elysia()
  .get(
    "/", 
    () => "Hello World", 
    {
      beforeHandler: ({ flowcoreUser, params }) => {
        return new RequestedAccessService(flowcoreUser)
          .onDataCore(FrnAction.READ, params.tenant)
          .evaluate()
      },
      params: t.Object({
        tenant: t.String()
      })
    }
  )
```

----------------------------------------

TITLE: Creating Flowcore Personal Access Token (PAT) - Bash
DESCRIPTION: This snippet demonstrates how to generate a new Flowcore Personal Access Token (PAT) using the Flowcore CLI. The PAT is crucial for authenticating with Flowcore services and must be saved securely immediately after creation as it will not be displayed again.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore MCP Servers/cursor-configuration.mdx#_snippet_0

LANGUAGE: bash
CODE:
```
flowcore auth new pat <name you want to give to the token>
```

----------------------------------------

TITLE: Creating Flowcore API Key - Bash
DESCRIPTION: This snippet illustrates how to create a Flowcore API Key using the Flowcore CLI, specifying the tenant and a desired name for the key. While optional, this API key is recommended for MCP ingestion and, similar to the PAT, must be saved securely as it will not be shown again.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore MCP Servers/cursor-configuration.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
flowcore auth new key -t <tenant> <name you want to give to the api key>
```

----------------------------------------

TITLE: Creating Elysia Transformer Routers with Flowcore (TypeScript)
DESCRIPTION: This TypeScript snippet defines an `ElysiaTransformerBuilder` for creating API routes that handle Flowcore events. It demonstrates a factory function `transformerFactory` to configure the builder with a secret and an optional success handler, and then shows how to register multiple event types (created, updated, deleted) with their respective schemas and handlers to generate an Elysia router.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Automation/cursor.mdx#_snippet_3

LANGUAGE: TypeScript
CODE:
```
class ElysiaTransformerBuilder extends TransformerBuilder<typeof FlowcoreEventSchema> {
  public getRouter(prefix?: string) {
    return new Elysia().post(
      `/${prefix ?? ""}${this.flowType}`,
      async ({ body, headers, set }) => {
        const response = await this.handleEvent(body, headers["x-secret"])
        set.status = response.statusCode
        return response
      },
      {
        body: FlowcoreEventSchema,
        headers: TransformerHeadersSchema,
        response: TransformerResponseSchema,
      },
    )
  }
}

type ConstructedTransformerFactory = (flowType: string) => ElysiaTransformerBuilder
type TransformerOptions = {
  onSuccess?: TransformerSuccessHandler
  secret: string
}

const transformerFactory = (options: TransformerOptions): ConstructedTransformerFactory => {
  return (flowType: string) => {
    const builder = new ElysiaTransformerBuilder(flowType).withSecret(options.secret)
    if (options.onSuccess) {
      builder.withSuccessHandler(options.onSuccess)
    }
    return builder
  }
}

export const transformerBuilder = transformerFactory({
  onSuccess: redisPredicate.notify,
  secret: env.TRANSFORMER_SECRET,
})

// using the transformer factory to create a transformer router
export default transformerBuilder(organizationV0Contract.flowType)
  .onEventType(organizationV0Contract.eventTypes.created, EventOrganizationV0CreatedSchema, organizationCreatedHandler)
  .onEventType(organizationV0Contract.eventTypes.updated, EventOrganizationV0UpdatedSchema, organizationUpdatedHandler)
  .onEventType(organizationV0Contract.eventTypes.deleted, EventOrganizationV0DeletedSchema, organizationDeletedHandler)
  .getRouter()
```

----------------------------------------

TITLE: Defining a Data Core in YAML
DESCRIPTION: This YAML manifest defines a basic Data Core, specifying its tenant, name, description, and nested flow types with their respective event types. This structure is used to create or update a Data Core in Flowcore using the `apply` command.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore CLI/create-resources-cli.mdx#_snippet_0

LANGUAGE: yaml
CODE:
```
tenant: example-tenant
dataCore:
  name: example-data-core
  description: "An example Data Core"
  flowTypes:
    example:
      description: "An example Flow Type"
      eventTypes:
        example.event.0:
          description: "An example event"
```

----------------------------------------

TITLE: Building and Using Flowcore Webhooks (TypeScript)
DESCRIPTION: This TypeScript example illustrates the configuration and usage of the `WebhookBuilder` from `@flowcore/sdk-transformer-core`. It shows how to initialize the builder with environment variables, apply an optional Redis predicate for retries, and then build and send specific events like `EventTenantCreated` through the configured webhook.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Automation/cursor.mdx#_snippet_2

LANGUAGE: TypeScript
CODE:
```
// WebhookBuilder is imported from @flowcore/sdk-transformer-core
export const webhookBuilder = new WebhookBuilder({
  baseUrl: env.FLOWCORE_WEBHOOK_BASE_URL,
  tenant: env.FLOWCORE_TENANT,
  dataCore: env.FLOWCORE_DATA_CORE,
  apiKey: env.FLOWCORE_API_KEY,
}).withPredicate({
  predicate: redisPredicate.check,
  options: {
    maxAttempts: 20,
    attemptDelayMs: 250,
  },
})

// using the builder to create a webhook
export const webhookTenantCreated = webhookBuilder.buildWebhook<EventTenantCreated>(
  tenantContract.flowType,
  tenantContract.eventTypes.created,
)

// using the webhook to send an event
await webhookTenantCreated.send(event)
```

----------------------------------------

TITLE: Creating an API Key in TypeScript
DESCRIPTION: Generates a new API key for a specified tenant. The API key value is returned only once upon creation and must be stored securely. This operation requires bearer token authentication.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore SDK/index.mdx#_snippet_6

LANGUAGE: typescript
CODE:
```
import { ApiKeyCreateCommand, FlowcoreClient } from "@flowcore/sdk"

const command = new ApiKeyCreateCommand({
  tenantId: "your-tenant-id",
  name: "my-new-api-key"
})

const result = await client.execute(command)
// Result will contain:
// {
//   id: string;
//   name: string;
//   createdAt: string;
//   value: string; // The API key value - store this securely!
// }
```

----------------------------------------

TITLE: Creating Flowcore API Key - Bash
DESCRIPTION: This command generates a new Flowcore API Key, which is recommended for MCP ingestion. It requires specifying the tenant ID and a descriptive name for the API key. Similar to PATs, the generated API key must be saved securely upon creation as it cannot be retrieved later.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Flowcore MCP Servers/claude-desktop-configuration.mdx#_snippet_1

LANGUAGE: bash
CODE:
```
flowcore auth new key -t <tenant> <name you want to give to the api key>
```

----------------------------------------

TITLE: Configuring Redis Service in Docker Compose
DESCRIPTION: This YAML configuration defines a Redis service for `docker-compose.yml`, exposing port 6379 and including a health check to ensure the Redis instance is ready for use in development or production environments.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Components/Libraries/Predicates/redis-predicate.mdx#_snippet_3

LANGUAGE: yaml
CODE:
```
# docker-compose.yml

services:
  redis:
      image: redis:7.2-alpine
      ports:
      - "6379:6379"
      healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 5s
      retries: 10
```

----------------------------------------

TITLE: Defining Flowcore IAM Policy for Dedicated Cluster (YAML)
DESCRIPTION: Provides a YAML definition for a Flowcore IAM Policy named `dedicated-cluster-policy`. This policy grants read and write access to all tenant and license resources, intended to be bound to the API key for the dedicated cluster.
SOURCE: https://github.com/flowcore-io/astro-flowcore-docs/blob/main/website/src/content/docs/Guides/Installation/index.mdx#_snippet_7

LANGUAGE: yaml
CODE:
```
// policy.yaml
apiVersion: iam.flowcore.io/v1
kind: Policy
metadata:
  name: dedicated-cluster-policy
  tenant: <tenant>
spec:
  version: "1.0.0"
  description: "Allows read and write access to all resources"
  policyDocuments:
    - resource: "frn::<tenant>:tenant/*"
      action: [
        "read",
        "write"
      ]
    - resource: "frn::<tenant>:license/*"
      action: [
        "read",
        "write"
      ]
```