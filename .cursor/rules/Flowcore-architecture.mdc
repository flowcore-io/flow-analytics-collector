---
description: if I ask you to look at the flowcore architecture
globs: 
alwaysApply: false
---
---
description: Flowcore Pathways
globs: 
alwaysApply: false
---
# Flowcore Platform Cursor Rules

This project uses the Flowcore Platform for event-driven architecture with the Pathways library for processing events. Below are the patterns, conventions, and examples for implementing Flowcore integrations.

## Project Structure

```
src/
├── pathways/
│   ├── pathways.ts              # Main pathways router configuration
│   ├── index.ts                 # Pathways exports
│   └── contracts/               # Event contracts and handlers
│       ├── {flowType}.ts        # Event schemas and types
│       └── {flowType}.handlers.ts # Event handlers and subscribers
├── app/api/
│   ├── transformer/             # Main transformer endpoint
│   └── transform/               # Specific flow type transformers
│       └── {flowType}/
└── env/
    └── server.ts               # Environment configuration
```

## Flowcore Configuration Files

This project uses a **multi-file configuration approach** for different environments:

### Core Configuration Files

```
flowcore.yml                    # Production configuration
flowcore.local.yml              # Local environment overrides  
flowcore.local.development.yml  # Local development proxy endpoints
```

### File Purposes

- **`flowcore.yml`**: Production configuration with all flow types, transformers, and scenarios
- **`flowcore.local.yml`**: Minimal file that overrides tenant for local development
- **`flowcore.local.development.yml`**: Development proxy endpoints for local event streaming

### Example Structure

**flowcore.yml** (Production):
```yaml
tenant: speedlocal
dataCore:
  name: speedlocal
  deleteProtection: true
  description: "SpeedLocal Admin - Scientific Dataset Management Platform"
  flowTypes:
    user.0:
      description: "actions and events related to user management"
      eventTypes:
        user.created.0:
          description: "a new user has been created"
        user.updated.0:
          description: "a user has been updated"
        user.deleted.0:
          description: "a user has been deleted"
        user.invited.0:
          description: "a user has been invited"
        invitation.accepted.0:
          description: "an invitation has been accepted"
    
    file.0:
      description: "actions and events related to file operations"
      eventTypes:
        file.uploaded.0:
          description: "a file has been uploaded"
        file.processing.started.0:
          description: "file processing has started"
        file.processing.completed.0:
          description: "file processing has completed"
        file.processing.failed.0:
          description: "file processing has failed"
        file.deleted.0:
          description: "a file has been deleted"
    
    # ... other flow types (dataset.0, duckdb.0, job.0, system.0)
```

**flowcore.local.yml** (Local Override):
```yaml
tenant: jbiskur
```

**flowcore.local.development.yml** (Development Proxies):
```yaml
development:
  proxyEndpoints:
    users:
      description: "transformer for user management"
      dataCore: speedlocal-admin-dev
      flowType: user.0
      events:
        - user.created.0
        - user.updated.0
        # ... other user events
      endpoints:
        - "user.0"
    # ... other proxy endpoints
```

## Writing Events to Pathways

### Method Signature

The pathways write method expects exactly **2 arguments**:

```typescript
await pathways.write(
  "{flowType}/{eventType}",  // Single string combining flow and event type
  {
    data: eventObject        // Event data wrapped in object with 'data' property
  }
)
```

### Important Notes

- Use the `pathways` builder object (PathwaysBuilder), **NOT** the `pathwaysRouter` (PathwayRouter)
- The first argument is a single string in format `"flowType/eventType"`
- The second argument must wrap your event data in an object with a `data` property
- Event handlers will receive the event and process it to update the database

### Example Usage

```typescript
import { pathways } from "@/pathways";
import { FlowcoreSpeedLocal, type EventUserInvited } from "@/pathways/contracts/speedlocal.0";

// Create event object matching the schema
const userInvitedEvent: EventUserInvited = {
  invitationId: "uuid-here",
  email: "user@example.com",
  role: "collaborator",
  invitedBy: "admin-user-id",
  invitedAt: new Date().toISOString(),
  expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
};

// Write to pathways (triggers the handler)
await pathways.write(
  `${FlowcoreSpeedLocal.flowType}/${FlowcoreSpeedLocal.eventType.userInvited}`,
  {
    data: userInvitedEvent
  }
);
```

### Service Layer Pattern

Services should send events to pathways instead of writing directly to the database:

```typescript
export class UserManagementService {
  async inviteUser(input: CreateInvitationInput): Promise<{ invitationId: string; token: string }> {
    // Business logic validation...
    
    const invitationId = uuidv4();
    const token = uuidv4();
    
    // Create event for pathways
    const userInvitedEvent: EventUserInvited = {
      invitationId,
      email: input.email,
      role: input.role,
      invitedBy: input.invitedBy,
      invitedAt: new Date().toISOString(),
      expiresAt: expiresAt.toISOString(),
    };

    // Write to pathways - this triggers the handler to create the invitation in the database
    await pathways.write(
      `${FlowcoreSpeedLocal.flowType}/${FlowcoreSpeedLocal.eventType.userInvited}`,
      {
        data: userInvitedEvent,
      }
    );

    return { invitationId, token };
  }
}
```

### Common Mistakes to Avoid

❌ **Wrong - 3 arguments:**
```typescript
await pathways.write(flowType, eventType, eventData)
```

❌ **Wrong - Using router instead of builder:**
```typescript
await pathwaysRouter.write(...)
```

❌ **Wrong - Event data not wrapped:**
```typescript
await pathways.write("flowType/eventType", eventData)
```

✅ **Correct:**
```typescript
await pathways.write("flowType/eventType", { data: eventData })
```

## Pathway Execution and Error Handling

### Understanding Pathway Execution Timing

**Important**: When `pathways.write()` resolves, the event handler has **already executed successfully**. You do not need timeouts or delays.

```typescript
// ✅ CORRECT: Handler execution is complete when promise resolves
try {
  await pathways.write("user.0/user.created.0", { data: userEvent });
  
  // At this point, the handler has run and database operations are complete
  const createdUser = await db.query.users.findFirst({
    where: eq(users.email, userEvent.email)
  });
  
  if (!createdUser) {
    throw new Error("Handler succeeded but user not found - indicates handler logic issue");
  }
} catch (error) {
  console.error("Pathway write failed:", error);
  // Handle the error appropriately
}
```

### Error Handling Best Practices

**Never use timeouts** - they indicate misunderstanding of pathway execution:

```typescript
// ❌ WRONG: Using setTimeout suggests misunderstanding
await pathways.write("user.0/user.created.0", { data: userEvent });
await new Promise(resolve => setTimeout(resolve, 100)); // DON'T DO THIS
```

**Proper error handling pattern:**

```typescript
// ✅ CORRECT: Proper error handling with fallback
try {
  await pathways.write("user.0/user.created.0", { data: userEvent });
  
  // Handler has completed successfully - fetch the result
  const user = await db.query.users.findFirst({
    where: eq(users.email, userEvent.email)
  });
  
  return user;
} catch (error) {
  console.error("User creation via pathway failed:", error);
  
  // Decide on fallback strategy:
  // 1. Re-throw error to fail fast
  // 2. Create temporary user object
  // 3. Retry mechanism
  // 4. Queue for later processing
  
  throw new Error(`Failed to create user: ${error.message}`);
}
```

### Handler Error Propagation

When a handler throws an error, `pathways.write()` will reject:

```typescript
// Handler throws error
export async function handlerUserCreated(event) {
  try {
    await db.insert(users).values(userData);
  } catch (error) {
    logger.error("Database insert failed", error);
    throw error; // This will cause pathways.write() to reject
  }
}

// Calling code receives the rejection
try {
  await pathways.write("user.0/user.created.0", { data: userEvent });
  // This line only executes if handler succeeded
} catch (error) {
  // This catches handler errors
  console.error("Handler failed:", error);
}
```

### Critical Auth Flow Pattern

For authentication flows where user must be created, use graceful fallback:

```typescript
async function createUserInSession(userEvent: EventUserCreated) {
  try {
    // Attempt pathway creation
    await pathways.write("user.0/user.created.0", { data: userEvent });
    
    // Fetch created user (handler succeeded)
    const dbUser = await db.query.users.findFirst({
      where: eq(users.email, userEvent.email)
    });
    
    if (!dbUser) {
      throw new Error("Handler succeeded but user not found in database");
    }
    
    return dbUser;
  } catch (error) {
    console.error("Failed to create user via pathway:", error);
    
    // Create temporary user object as fallback for auth
    // This ensures user can still log in even if pathway fails
    return {
      id: userEvent.userId,
      email: userEvent.email,
      name: userEvent.metadata?.name,
      role: userEvent.role,
      isActive: true,
      keycloakId: userEvent.metadata?.keycloakId,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
  }
}
```

## Flow Type Organization

### Multi-Flow Type Structure

Instead of a single monolithic flow type, organize events into **domain-specific flow types**:

```
user.0     - User management events
file.0     - File operation events  
dataset.0  - Dataset management events
duckdb.0   - DuckDB operation events
job.0      - Processing job events
system.0   - System monitoring events
```

### Benefits

- **Better Organization**: Events grouped by logical domain
- **Independent Scaling**: Each flow type can be managed separately
- **Clear Boundaries**: Easier to understand and maintain
- **Specialized Handling**: Different transformers for different event types

### Contract Updates

Update your contracts to use the new flow type structure:

```typescript
export const FlowcoreSpeedLocal = {
  // User events now use user.0 flow type
  userFlowType: "user.0",
  userEventType: {
    created: "user.created.0",
    updated: "user.updated.0",
    deleted: "user.deleted.0",
    invited: "user.invited.0",
    invitationAccepted: "invitation.accepted.0",
  },
  
  // File events use file.0 flow type
  fileFlowType: "file.0",
  fileEventType: {
    uploaded: "file.uploaded.0",
    processingStarted: "file.processing.started.0",
    processingCompleted: "file.processing.completed.0",
    processingFailed: "file.processing.failed.0",
    deleted: "file.deleted.0",
  },
  
  // ... other flow types
} as const;
```

## Development Commands

### Package.json Scripts

Add these scripts to your `package.json` for Flowcore development:

```json
{
  "scripts": {
    "flowcore:apply:production": "flowcore apply -f flowcore.yml",
    "flowcore:apply:staging": "flowcore apply -f flowcore.yml -f flowcore.staging.yml", 
    "flowcore:apply:dev": "flowcore data-core apply -f flowcore.yml -f flowcore.local.yml",
    "flowcore:stream": "env-cmd -x flowcore scenario local -f flowcore.yml -f flowcore.local.yml -f flowcore.local.development.yml -s now -e http://localhost:3000/api/transform -H \"X-Secret: \\$FLOWCORE_TRANSFORMER_SECRET\"",
    "flowcore:backfill": "env-cmd -x flowcore scenario local -f flowcore.yml -f flowcore.local.yml -f flowcore.local.development.yml -z 5 -e http://localhost:3000/api/transform -H \"X-Secret: \\$FLOWCORE_TRANSFORMER_SECRET\""
  },
  "devDependencies": {
    "env-cmd": "^10.1.0"
  }
}
```

### Command Purposes

- **`flowcore:apply:production`**: Deploy configuration to production
- **`flowcore:apply:dev`**: Apply configuration to development environment
- **`flowcore:stream`**: Stream events in real-time for development
- **`flowcore:backfill`**: Backfill historical events for testing

### Environment Variables Required

```bash
FLOWCORE_TENANT=jbiskur                    # For local development
FLOWCORE_DATACORE=speedlocal-admin-dev     # Development data core
FLOWCORE_TRANSFORMER_SECRET=your-secret    # Webhook authentication
```

## Core Dependencies

```json
{
  "dependencies": {
    "@flowcore/pathways": "^0.11.0",
    "@flowcore/sdk": "^1.24.4", 
    "@flowcore/sdk-transformer-core": "^2.3.1",
    "@flowcore/data-pump": "^0.13.0",
    "@sinclair/typebox": "~0.32.15"
  },
  "devDependencies": {
    "env-cmd": "^10.1.0"
  }
}
```

## Environment Variables

Required environment variables for Flowcore integration:

| Variable | Type | Description | Default | Required |
|----|---|----|----|----|
| FLOWCORE_TENANT | string | Your Flowcore tenant name | - | ✓ |
| FLOWCORE_DATACORE | string | Data core name | - | ✓ |
| FLOWCORE_WEBHOOK_BASEURL | string | Base URL for Flowcore webhooks | - | ✓ |
| FLOWCORE_WEBHOOK_API_KEY | string | API key for Flowcore webhooks | - | ✓ |
| FLOWCORE_TRANSFORMER_SECRET | string | Secret for transformer authentication | - | ✓ |
| DEV_LOCAL_TRANSFORMER_BASEURL | string | Local transformer URL for development | - | |

## Data Core Structure

### Production Configuration

```yaml
tenant: speedlocal
dataCore:
  name: speedlocal
  deleteProtection: true
  description: "SpeedLocal Admin - Scientific Dataset Management Platform"
  flowTypes:
    user.0:
      description: "actions and events related to user management"
      eventTypes:
        user.created.0:
          description: "a new user has been created"
        user.updated.0:
          description: "a user has been updated"
        user.deleted.0:
          description: "a user has been deleted"
        user.invited.0:
          description: "a user has been invited"
        invitation.accepted.0:
          description: "an invitation has been accepted"
    
    file.0:
      description: "actions and events related to file operations"
      eventTypes:
        file.uploaded.0:
          description: "a file has been uploaded"
        file.processing.started.0:
          description: "file processing has started"
        file.processing.completed.0:
          description: "file processing has completed"
        file.processing.failed.0:
          description: "file processing has failed"
        file.deleted.0:
          description: "a file has been deleted"
    
    # ... other flow types (dataset.0, duckdb.0, job.0, system.0)
```

### Scenario and Transformers

```yaml
scenario:
  name: "speedlocal-admin"
  description: "SpeedLocal Admin event processing for scientific dataset management"
  prefix: "speedlocal"
  
  transformers:
    users:
      description: "transformer for user management"
      dataCore: speedlocal
      flowType: user.0
      shell: flowcoreio/adapter-nodejs-transformer-shell:2.4.1
      events:
        - user.created.0
        - user.updated.0
        - user.deleted.0
        - user.invited.0
        - invitation.accepted.0
      parameters:
        - name: PROXY_ENDPOINT
          type: manual
          value: "http://localhost:3000/api/transformer"
        - name: PROXY_HEADER_SECRET
          type: secret
          value: speedlocal-admin-dev-webhook-secret
      blueprint:
        artifactUrl: "https://flowcore-public-runtimes.s3.eu-west-1.amazonaws.com/transformer-proxy-1.4.1.zip"
    
    files:
      size: MEDIUM
      pageSize: 10
      description: "transformer for file operations"
      dataCore: speedlocal
      flowType: file.0
      shell: flowcoreio/adapter-nodejs-transformer-shell:2.4.1
      events:
        - file.uploaded.0
        - file.processing.started.0
        - file.processing.completed.0
        - file.processing.failed.0
        - file.deleted.0
      parameters:
        - name: PROXY_ENDPOINT
          type: manual
          value: "http://localhost:3000/api/transform/file.0"
        - name: PROXY_HEADER_SECRET
          type: secret
          value: speedlocal-admin-dev-webhook-secret
      blueprint:
        artifactUrl: "https://flowcore-public-runtimes.s3.eu-west-1.amazonaws.com/transformer-proxy-1.4.1.zip"
        processTimeout: 60000
    
    # ... other transformers (datasets, duckdb, jobs, system)
```

### File Transformers (Special Configuration)

For file processing transformers that need more resources:

```yaml
files:
  size: MEDIUM          # More resources for file processing
  pageSize: 10         # Smaller batches for large files
  description: "transformer for file operations"
  dataCore: speedlocal
  flowType: file.0
  events:
    - file.uploaded.0
    - file.processing.started.0
    - file.processing.completed.0
    - file.processing.failed.0
    - file.deleted.0
  parameters:
    - name: PROXY_ENDPOINT
      type: manual
      value: "http://localhost:3000/api/transform/file.0"  # Specialized endpoint
  blueprint:
    processTimeout: 60000  # Extended timeout for file processing
```

## Event Contracts

### Contract Definition Pattern

Create contracts in `src/pathways/contracts/{flowType}.ts`:

```typescript
import { z } from "zod";

export const FlowcoreSpeedLocal = {
  flowType: "speedlocal.0",
  eventType: {
    // User Management Events  
    userCreated: "user.created.0",
    userUpdated: "user.updated.0",
    userDeleted: "user.deleted.0",
    userInvited: "user.invited.0",
    invitationAccepted: "invitation.accepted.0",

    // File Operation Events
    fileUploaded: "file.uploaded.0",
    fileProcessingStarted: "file.processing.started.0",
    fileProcessingCompleted: "file.processing.completed.0",
    fileProcessingFailed: "file.processing.failed.0",
    fileDeleted: "file.deleted.0",

    // ... other event types
  },
} as const;

// Event Schemas using Zod
export const EventUserCreatedSchema = z.object({
  userId: z.string(),
  email: z.string().email(),
  role: z.enum(["admin", "collaborator", "viewer"]),
  invitedBy: z.string().optional(),
  createdAt: z.string().datetime(),
  metadata: z.record(z.string(), z.unknown()).optional(),
});

export const EventUserInvitedSchema = z.object({
  invitationId: z.string(),
  email: z.string().email(),
  role: z.enum(["admin", "collaborator", "viewer"]),
  invitedBy: z.string(),
  invitedAt: z.string().datetime(),
  expiresAt: z.string().datetime(),
});

// Type Exports
export type EventUserCreated = z.infer<typeof EventUserCreatedSchema>;
export type EventUserInvited = z.infer<typeof EventUserInvitedSchema>;
```

### Handler Pattern

Create handlers in `src/pathways/contracts/{flowType}.handlers.ts`:

```typescript
import { FlowcoreEvent } from "@flowcore/pathways";
import { db } from "@/db";
import { users, invitations } from "@/db/schema";
import type { EventUserCreated, EventUserInvited, EventInvitationAccepted } from "./speedlocal.0";

export async function handlerUserInvited(
  event: Omit<FlowcoreEvent, "payload"> & { payload: EventUserInvited }
) {
  console.log(`Handle ${event.validTime} ${event.flowType} ${event.eventType} ${event.eventId}`);
  
  const payload = event.payload;
  
  // Create invitation in database
  await db.insert(invitations).values({
    id: payload.invitationId,
    email: payload.email,
    role: payload.role,
    invitedBy: payload.invitedBy,
    token: payload.invitationId, // Use invitationId as token
    expiresAt: new Date(payload.expiresAt),
    createdAt: new Date(payload.invitedAt),
  });
}

export async function handlerUserCreated(
  event: Omit<FlowcoreEvent, "payload"> & { payload: EventUserCreated }
) {
  console.log(`Handle ${event.validTime} ${event.flowType} ${event.eventType} ${event.eventId}`);
  
  const payload = event.payload;
  
  // Create user in database
  await db.insert(users).values({
    id: payload.userId,
    email: payload.email,
    name: payload.metadata?.firstName && payload.metadata?.lastName 
      ? `${payload.metadata.firstName} ${payload.metadata.lastName}`
      : payload.email.split("@")[0],
    role: payload.role,
    isActive: true,
    keycloakId: payload.metadata?.keycloakId as string,
    createdAt: new Date(payload.createdAt),
  });
}

export async function handlerInvitationAccepted(
  event: Omit<FlowcoreEvent, "payload"> & { payload: EventInvitationAccepted }
) {
  console.log(`Handle ${event.validTime} ${event.flowType} ${event.eventType} ${event.eventId}`);
  
  const payload = event.payload;
  
  // Mark invitation as accepted
  await db.update(invitations)
    .set({ 
      acceptedAt: new Date(payload.acceptedAt),
      acceptedBy: payload.userId,
    })
    .where(eq(invitations.id, payload.invitationId));
}
```

## Main Pathways Router

Create the main router in `src/pathways/pathways.ts`:

```typescript
import env from "@/env/server";
import { noOpLogger } from "@flowcore/data-pump";
import { PathwayRouter, PathwaysBuilder, createPostgresPathwayState } from "@flowcore/pathways";

// Import contracts and handlers
import * as speedlocalContract from "./contracts/speedlocal.0";
import { 
  handlerUserCreated,
  handlerUserInvited,
  handlerInvitationAccepted,
  // ... other handlers
} from "./contracts/speedlocal.0.handlers";

// PostgreSQL state management
const postgresState = createPostgresPathwayState({
  connectionString: env.POSTGRES_CONNECTION_STRING,
  tableName: "_pathways_state",
});

export const pathways = new PathwaysBuilder({
  baseUrl: env.FLOWCORE_WEBHOOK_BASEURL,
  tenant: env.FLOWCORE_TENANT,
  dataCore: env.FLOWCORE_DATACORE,
  apiKey: env.FLOWCORE_WEBHOOK_API_KEY,
  logger: noOpLogger,
  pathwayTimeoutMs: 60_000,
})
  .withPathwayState(postgresState)

  // User Management Events
  .register({
    flowType: speedlocalContract.FlowcoreSpeedLocal.flowType,
    eventType: speedlocalContract.FlowcoreSpeedLocal.eventType.userInvited,
    schema: speedlocalContract.EventUserInvitedSchema,
    writable: true,
  })
  .handle("speedlocal.0/user.invited.0", handlerUserInvited)
  
  .register({
    flowType: speedlocalContract.FlowcoreSpeedLocal.flowType,
    eventType: speedlocalContract.FlowcoreSpeedLocal.eventType.userCreated,
    schema: speedlocalContract.EventUserCreatedSchema,
    writable: true,
  })
  .handle("speedlocal.0/user.created.0", handlerUserCreated)
  
  .register({
    flowType: speedlocalContract.FlowcoreSpeedLocal.flowType,
    eventType: speedlocalContract.FlowcoreSpeedLocal.eventType.invitationAccepted,
    schema: speedlocalContract.EventInvitationAcceptedSchema,
    writable: true,
  })
  .handle("speedlocal.0/invitation.accepted.0", handlerInvitationAccepted)

  // ... register other events

// Export the router
export const pathwaysRouter = new PathwayRouter(pathways, env.FLOWCORE_TRANSFORMER_SECRET || "_");
```

### Pathways Index File

Create `src/pathways/index.ts` for clean exports:

```typescript
// Re-export pathways and related utilities
export { pathways, pathwaysRouter } from "./pathways";

// Re-export contracts for easier importing
export * from "./contracts/speedlocal.0";
```

## API Endpoints

### Main Transformer Route

Create `src/app/api/transformer/route.ts`:

```typescript
import { pathwaysRouter } from "@/pathways/pathways";
import { NextRequest, NextResponse } from "next/server";

export const POST = async (req: NextRequest) => {
  try {
    const event = await req.json();
    const secret = req.headers.get("x-secret") ?? "";
    
    console.log("Received event", { event, headers: req.headers });
    
    await pathwaysRouter.processEvent(event, secret);
    
    return new NextResponse("OK", { status: 200 });
  } catch (error) {
    console.error("Error processing event", { error });
    return new NextResponse((error as Error).message, { status: 500 });
  }
};
```

### Specific Flow Type Transformers

For specific flow types (like file processing), create `src/app/api/transform/{flowType}/route.ts`:

```typescript
import { NextRequest, NextResponse } from "next/server";
// Import specific transformer logic for this flow type

export const POST = async (req: NextRequest) => {
  // Handle specific flow type events
  // This endpoint is used when you need different processing 
  // or resources for specific event types
};
```

## File Pathway Pattern

For file events, use the `isFilePathway` flag:

```typescript
.register({
  flowType: fileContract.FlowcoreFile.flowType,
  eventType: fileContract.FlowcoreFile.eventType.uploaded,
  schema: fileContract.EventFileUploadedPayload,
  isFilePathway: true, // Important for file processing
  writable: true,
})
```

## Best Practices

### 1. Event Schema Design
- Use Zod for runtime validation and type safety
- Keep schemas simple and focused
- Use optional fields for backward compatibility
- Version your event types (e.g., `entity.created.0`)

### 2. Handler Implementation
- Always log event processing for debugging
- Use transactions for database operations
- Handle errors gracefully and provide meaningful error messages
- Keep handlers focused on single responsibility

### 3. Service Layer Pattern
- Services send events to pathways instead of writing directly to database
- Handlers receive events and perform database operations
- This creates proper event-driven architecture

### 4. Multi-File Configuration
- Use separate flowcore.yml files for different environments
- Keep production configuration complete in main flowcore.yml
- Use flowcore.local.yml for simple tenant overrides
- Use flowcore.local.development.yml for development proxy endpoints

### 5. Flow Type Organization
- Split events into logical domain-specific flow types
- Use consistent naming: `user.0`, `file.0`, `dataset.0`, etc.
- Each flow type can have its own transformer configuration

### 6. Development Workflow
- Use `flowcore:stream` for real-time event development
- Use `flowcore:backfill` for testing with historical events
- Use `env-cmd` package for environment variable management

### 7. State Management
- Use PostgreSQL state for production reliability
- Include proper connection string configuration
- Use dedicated table for pathway state

### 8. Error Handling
- Implement proper error logging
- Return appropriate HTTP status codes
- Use try-catch patterns for async operations

### 9. Security
- Always validate webhook secrets
- Use proper HTTPS endpoints in production
- Validate incoming event payloads

## Example Implementation Flow

1. **Define Event Contract**: Create schema and types in `contracts/{flowType}.ts`
2. **Implement Handlers**: Create business logic in `contracts/{flowType}.handlers.ts`
3. **Register in Router**: Add to main `pathways.ts` configuration
4. **Configure Flowcore**: Update `flowcore.yml` with transformer configuration
5. **Update Service Layer**: Modify services to send events to pathways
6. **Test Locally**: Use development scripts to stream events
7. **Deploy**: Apply configuration to production environment

## Debugging

### Local Development
```bash
# Stream events in real-time
yarn flowcore:stream

# Backfill historical events
yarn flowcore:backfill

# Apply configuration changes
yarn flowcore:apply:dev
```

### Production Monitoring
- Monitor transformer endpoint logs
- Check Flowcore dashboard for event processing status
- Validate pathway state in database
- Monitor webhook endpoint health